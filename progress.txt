## Codebase Patterns
- Tauri v2 + React + TypeScript + Tailwind CSS app (macOS desktop)
- Rust backend in src-tauri/src/, React frontend in src/
- Config stored at ~/.local/share/com.dictate.app/config.json (config.rs: load_config/save_config)
- History stored at ~/.local/share/com.dictate.app/history.json (history.rs: load_history/save_history/add_entry)
- Models stored at ~/.local/share/com.dictate.app/models/
- DictationState enum in state.rs uses #[serde(tag = "type")] for discriminated union serialization
- SharedState = Arc<parking_lot::Mutex<AppState>> — use .lock() directly (no .unwrap())
- Tauri commands: #[tauri::command] fn name(...), registered in .invoke_handler(tauri::generate_handler![...])
- Settings UI in ModelSettings.tsx uses toggle pattern: useState + invoke get/set commands + blue/gray pill toggle
- Overlay in Overlay.tsx renders based on DictationState type, returns null for Idle
- Frontend types in src/types.ts must match Rust DictationState enum variants
- Transcription pipeline in lib.rs: Whisper output → trim() → vocab corrections (if enabled) → history::add_entry() → paste_text() OR CorrectionPreview state
- CorrectionPreview flow: corrections found → store pending_original_text/pending_corrected_text in AppState → emit CorrectionPreview state → frontend calls accept_corrections or undo_corrections
- paste_text() in input/paste.rs handles clipboard + Cmd+V simulation + clipboard restore
- regex crate added in US-002 for word-boundary matching
- Vocabulary CRUD commands in lib.rs: get_vocabulary, add_vocab_entry, update_vocab_entry, delete_vocab_entry — no SharedState needed, direct disk I/O
- Timestamp-based IDs: SystemTime::now().duration_since(UNIX_EPOCH).as_millis() as u64 (used for HistoryEntry and VocabEntry)
- Modal components use visible/onClose props pattern, return null when !visible, fetch data in useEffect([visible])
---

## 2026-02-15 - US-001
- Implemented vocabulary storage module in src-tauri/src/vocabulary.rs
- VocabEntry struct (id, phrase, replacement, enabled) and Vocabulary wrapper struct
- CRUD functions: load_vocabulary, save_vocabulary, add_entry, update_entry, delete_entry
- Storage at ~/.local/share/com.dictate.app/vocabulary.json
- Added mod vocabulary to lib.rs
- Files changed: src-tauri/src/vocabulary.rs (new), src-tauri/src/lib.rs
- **Learnings for future iterations:**
  - Follows same pattern as config.rs and history.rs: path function, load with default fallback, save with dir creation
  - default_true() helper already exists in config.rs but vocabulary.rs has its own private copy (different module scope)
  - Dead code warnings are expected until Tauri commands reference the module in later stories
---

## 2026-02-15 - US-002
- Implemented text correction engine with apply_corrections() in vocabulary.rs
- Added regex = "1" dependency to Cargo.toml
- CorrectionApplied struct (original, replacement, position) and CorrectionResult struct (text, corrections)
- apply_corrections() uses regex word boundaries (\b) with case-insensitive matching
- Case preservation: ALL CAPS → uppercased replacement, Title Case → first char uppercased, lowercase → as-is
- Replacements applied from end to start to preserve string positions
- 8 unit tests: basic replacement, word boundary safety, case preservation (3 variants), multiple replacements, disabled entries, empty vocabulary
- Files changed: src-tauri/Cargo.toml, src-tauri/src/vocabulary.rs
- **Learnings for future iterations:**
  - Use (?i) flag in regex for case-insensitive matching combined with \b word boundaries
  - When doing multiple string replacements, apply from end to start to keep positions valid
  - regex::escape() is essential to escape special regex characters in user-provided phrases
  - All 8 tests pass with `cargo test` in project root
---

## 2026-02-15 - US-003
- Added vocab_enabled: bool field to AppConfig in config.rs with #[serde(default = "default_true")]
- Added vocab_enabled: bool field to AppState in state.rs with default true
- Initialized vocab_enabled from config in lib.rs run() setup (same pattern as smart_paste)
- Added get_vocab_enabled and set_vocab_enabled Tauri commands following set_smart_paste pattern
- Registered both commands in invoke_handler generate_handler! macro
- Files changed: src-tauri/src/config.rs, src-tauri/src/state.rs, src-tauri/src/lib.rs
- **Learnings for future iterations:**
  - set_vocab_enabled follows exact same pattern as set_smart_paste: update SharedState lock, then load/mutate/save config
  - The invoke_handler line is getting long — commands listed alphabetically by group makes it easier to find additions
  - default_true() helper exists in config.rs (not exported); vocabulary.rs has its own private copy
---

## 2026-02-15 - US-004
- Added four Tauri CRUD commands for vocabulary management in lib.rs
- get_vocabulary() returns Vec<VocabEntry> from vocabulary::load_vocabulary().entries
- add_vocab_entry(phrase, replacement) creates VocabEntry with id = current timestamp_ms, enabled = true
- update_vocab_entry(id, phrase, replacement, enabled) delegates to vocabulary::update_entry()
- delete_vocab_entry(id) delegates to vocabulary::delete_entry()
- Registered all four commands in invoke_handler generate_handler! macro
- Files changed: src-tauri/src/lib.rs
- **Learnings for future iterations:**
  - Vocabulary CRUD commands don't need SharedState since they read/write directly to disk (unlike config toggles which cache in AppState)
  - Timestamp ID pattern: SystemTime::now().duration_since(UNIX_EPOCH).as_millis() as u64 — same as HistoryEntry
  - All commands follow the .map_err(|e| format!(...)) pattern for converting anyhow::Error to String for Tauri
---

## 2026-02-15 - US-005
- Added Personal Vocabulary toggle to Settings UI in ModelSettings.tsx
- vocabEnabled state initialized with useState<boolean>(true), loaded on mount via invoke('get_vocab_enabled')
- handleToggleVocab follows exact same pattern as handleToggleSmartPaste (optimistic update, rollback on error)
- Toggle placed below Launch at Login in the footer section, same blue/gray pill styling
- Files changed: src/components/ModelSettings.tsx
- **Learnings for future iterations:**
  - Toggle pattern in ModelSettings.tsx: useState + useEffect invoke + handler with optimistic update + rollback
  - Pre-existing TS error: @tauri-apps/plugin-autostart module not found — not related to vocabulary changes
  - All toggles in footer share identical JSX structure: button > (div.flex-col > span.label + span.subtitle) + div.pill > div.knob
---

## 2026-02-15 - US-006
- Created VocabularyModal.tsx component with full CRUD UI for vocabulary entries
- Modal takes visible/onClose props, returns null when not visible (same pattern as Settings.tsx)
- Loads entries on mount via invoke('get_vocabulary'), displays scrollable list
- Add form at top: two text inputs (phrase, replacement) + Add button
- Each entry shows phrase → replacement, enabled toggle (small pill), and delete (X) button
- Empty state message: "No vocabulary entries yet. Add your first correction above."
- Dark glass-morphism styling: bg-black/90 backdrop-blur-xl rounded-2xl border-white/10, max-h-[400px] overflow-y-auto
- In ModelSettings.tsx: added showVocabModal state, "Manage Vocabulary..." link button (visible when vocabEnabled is true), rendered VocabularyModal
- Files changed: src/components/VocabularyModal.tsx (new), src/components/ModelSettings.tsx
- **Learnings for future iterations:**
  - Modal pattern: visible prop + return null when !visible, useEffect with [visible] dependency to fetch data
  - VocabularyModal uses absolute positioning (absolute inset-0) with bg-black/50 backdrop for overlay effect
  - The "Manage Vocabulary..." button is conditionally rendered only when vocabEnabled is true
  - VocabEntry interface in frontend mirrors Rust struct: { id: number, phrase: string, replacement: string, enabled: boolean }
  - Pre-existing TS error persists: @tauri-apps/plugin-autostart module not found — no new TS errors introduced
---

## 2026-02-15 - US-007
- Wired vocabulary corrections into the transcription pipeline in lib.rs
- Added CorrectionPreview variant to DictationState enum in state.rs with text, original_text, corrections fields
- Added pending_original_text and pending_corrected_text Option<String> fields to AppState
- After transcription: if vocab_enabled, load vocabulary and apply corrections; if corrections found, enter CorrectionPreview state instead of pasting
- History entry saved with corrected text; undo_corrections reverts it via history::update_most_recent_text()
- Added accept_corrections Tauri command: reads pending_corrected_text, pastes it, clears pending, sets Idle, hides overlay
- Added undo_corrections Tauri command: reads pending_original_text, updates history, pastes original, clears pending, sets Idle, hides overlay
- Added history::update_most_recent_text() function to history.rs for reverting history entries
- CorrectionPreview state ignored in toggle_recording (same as Processing/Downloading)
- Registered accept_corrections and undo_corrections in invoke_handler
- Files changed: src-tauri/src/state.rs, src-tauri/src/lib.rs, src-tauri/src/history.rs
- **Learnings for future iterations:**
  - DictationState::CorrectionPreview uses #[serde(skip_serializing_if = "Vec::is_empty")] on corrections field to match other skip patterns
  - accept_corrections and undo_corrections use run_on_main_thread for paste_text (macOS requires AppKit calls on main thread)
  - Pending text fields are stored as Option<String> in AppState, cleared after accept/undo
  - The CorrectionPreview state must be added to toggle_recording match as ignored (like Processing) to prevent re-recording during preview
  - history::update_most_recent_text() updates entries[0] since add_entry inserts at position 0
---
