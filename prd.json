{
  "project": "Dictate",
  "branchName": "ralph/personal-vocabulary",
  "description": "Personal Vocabulary — local correction layer between Whisper transcription output and paste, with whole-word matching, case preservation, correction preview in overlay, and undo hotkey",
  "userStories": [
    {
      "id": "US-001",
      "title": "Create vocabulary storage module",
      "description": "As a developer, I need a Rust module to load, save, and query vocabulary entries from a local JSON file so the correction layer has persistent storage.",
      "acceptanceCriteria": [
        "Create src-tauri/src/vocabulary.rs with VocabEntry struct: id (u64), phrase (String), replacement (String), enabled (bool, default true). Derive Debug, Clone, Serialize, Deserialize",
        "Create Vocabulary struct wrapping Vec<VocabEntry> with Serialize, Deserialize, Default derives",
        "Add vocabulary_path() function returning ~/.local/share/com.dictate.app/vocabulary.json (using dirs::data_dir(), same pattern as config_path() in config.rs and history_path() in history.rs)",
        "Add load_vocabulary() -> Vocabulary that reads from disk, returns Vocabulary::default() if file missing or corrupt (same pattern as load_config() in config.rs)",
        "Add save_vocabulary(vocabulary: &Vocabulary) -> Result<()> that writes to disk, creating directory if needed (same pattern as save_config() in config.rs)",
        "Add add_entry(entry: VocabEntry) -> Result<()> that loads, pushes entry, saves",
        "Add update_entry(id: u64, phrase: String, replacement: String, enabled: bool) -> Result<()> that loads, finds by id, updates fields, saves",
        "Add delete_entry(id: u64) -> Result<()> that loads, retains entries where id != target, saves",
        "Add mod vocabulary; to lib.rs",
        "Typecheck passes (cargo check in src-tauri)"
      ],
      "priority": 1,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-002",
      "title": "Implement text correction engine with tests",
      "description": "As a developer, I need a function that applies vocabulary replacements to text using whole-word boundary matching and case preservation, so Whisper's recurring mistakes are fixed automatically.",
      "acceptanceCriteria": [
        "Add regex = \"1\" to [dependencies] in src-tauri/Cargo.toml",
        "Add to vocabulary.rs: CorrectionApplied struct with fields: original (String), replacement (String), position (usize)",
        "Add to vocabulary.rs: CorrectionResult struct with fields: text (String), corrections (Vec<CorrectionApplied>). Both structs derive Debug, Clone, Serialize, Deserialize",
        "Add pub fn apply_corrections(text: &str, vocabulary: &Vocabulary) -> CorrectionResult that iterates enabled entries, builds regex with \\b word boundaries for each phrase, replaces all matches",
        "Case-preserving replacement: if matched text is all uppercase, replacement is uppercased; if first char is uppercase (Title Case), replacement first char is uppercased; otherwise replacement used as-is",
        "Return CorrectionResult with corrected text and list of all CorrectionApplied entries (one per match, not per vocab entry)",
        "If vocabulary is empty or no entries are enabled or no matches found, return original text with empty corrections vec",
        "Add #[cfg(test)] mod tests with tests: basic single replacement, word boundary safety (\"app\" does not match inside \"application\"), case preservation (lowercase, Title Case, ALL CAPS), multiple replacements in one text, disabled entries are skipped, empty vocabulary returns original text unchanged",
        "Typecheck passes (cargo check in src-tauri)",
        "Tests pass (cargo test in src-tauri)"
      ],
      "priority": 2,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-003",
      "title": "Add vocab_enabled config field and Tauri commands",
      "description": "As a developer, I need a vocab_enabled flag in AppConfig and corresponding Tauri commands so the frontend can toggle Personal Vocabulary on/off.",
      "acceptanceCriteria": [
        "Add vocab_enabled: bool field to AppConfig in config.rs with #[serde(default = \"default_true\")] so it defaults to true",
        "Add vocab_enabled: bool field to AppState in state.rs with default true",
        "In lib.rs setup: read vocab_enabled from config and set it on AppState (same pattern as smart_paste initialization)",
        "Add #[tauri::command] fn get_vocab_enabled(shared_state: State<SharedState>) -> bool that reads from shared state",
        "Add #[tauri::command] fn set_vocab_enabled(app: AppHandle, enabled: bool) -> Result<(), String> that updates shared state and saves to config (same pattern as set_smart_paste)",
        "Register both commands in invoke_handler generate_handler! macro",
        "Typecheck passes (cargo check in src-tauri)"
      ],
      "priority": 3,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-004",
      "title": "Add Tauri CRUD commands for vocabulary management",
      "description": "As a developer, I need Tauri commands for vocabulary CRUD operations so the frontend can manage vocabulary entries.",
      "acceptanceCriteria": [
        "Add #[tauri::command] fn get_vocabulary() -> Vec<VocabEntry> that calls vocabulary::load_vocabulary() and returns entries",
        "Add #[tauri::command] fn add_vocab_entry(phrase: String, replacement: String) -> Result<(), String> that creates VocabEntry with id = current timestamp_ms (same pattern as HistoryEntry id), enabled = true, and calls vocabulary::add_entry()",
        "Add #[tauri::command] fn update_vocab_entry(id: u64, phrase: String, replacement: String, enabled: bool) -> Result<(), String> that calls vocabulary::update_entry()",
        "Add #[tauri::command] fn delete_vocab_entry(id: u64) -> Result<(), String> that calls vocabulary::delete_entry()",
        "Register all four commands in invoke_handler generate_handler! macro",
        "Typecheck passes (cargo check in src-tauri)"
      ],
      "priority": 4,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-005",
      "title": "Add Personal Vocabulary toggle to Settings UI",
      "description": "As a user, I want a toggle in Settings to turn Personal Vocabulary on or off globally, so I can quickly disable it without deleting my entries.",
      "acceptanceCriteria": [
        "In ModelSettings.tsx: add vocabEnabled state (useState<boolean>(true))",
        "On mount (useEffect): call invoke<boolean>('get_vocab_enabled').then(setVocabEnabled)",
        "Add handleToggleVocab async function that calls invoke('set_vocab_enabled', { enabled: !vocabEnabled }) and updates local state (same pattern as handleToggleSmartPaste)",
        "Add toggle button in the settings footer section (mt-4 pt-4 border-t area) below the Launch at Login toggle, following the exact same layout pattern",
        "Toggle label: 'Personal Vocabulary' with subtitle: vocabEnabled ? 'Corrects transcriptions using your custom dictionary' : 'Vocabulary corrections are disabled'",
        "Toggle uses same blue/gray pill styling as Smart Paste and Launch at Login toggles",
        "Typecheck passes (npx tsc --noEmit)"
      ],
      "priority": 5,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-006",
      "title": "Add Manage Vocabulary modal in Settings",
      "description": "As a user, I want to add, edit, and delete vocabulary entries from a modal in Settings so I can build my personal dictionary.",
      "acceptanceCriteria": [
        "Create src/components/VocabularyModal.tsx component that takes visible: boolean and onClose: () => void props",
        "If !visible, return null (same pattern as Settings.tsx)",
        "On mount when visible: call invoke<VocabEntry[]>('get_vocabulary') to load entries",
        "Display scrollable list of entries, each showing phrase, arrow, replacement, enabled toggle, and delete (X) button",
        "Add form at top: two text inputs (phrase, replacement) and an 'Add' button. On submit call invoke('add_vocab_entry', { phrase, replacement }) then reload list",
        "Delete button calls invoke('delete_vocab_entry', { id }) then reloads list",
        "Per-entry enabled toggle calls invoke('update_vocab_entry', { id, phrase, replacement, enabled: !entry.enabled }) then reloads list",
        "Empty state: show 'No vocabulary entries yet. Add your first correction above.' message",
        "Style with dark glass-morphism matching existing UI: bg-black/90 backdrop-blur-xl rounded-2xl border border-white/10, max-h-[400px] overflow-y-auto for list",
        "In ModelSettings.tsx: add 'Manage Vocabulary' button below the Personal Vocabulary toggle (only shown when vocabEnabled is true). Add showVocabModal state. Render <VocabularyModal visible={showVocabModal} onClose={() => setShowVocabModal(false)} />",
        "Typecheck passes (npx tsc --noEmit)"
      ],
      "priority": 6,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-007",
      "title": "Wire corrections into transcription pipeline with preview state",
      "description": "As a developer, I need to apply vocabulary corrections after transcription and emit a CorrectionPreview state so the overlay can show what changed before pasting.",
      "acceptanceCriteria": [
        "Add CorrectionPreview variant to DictationState enum in state.rs: CorrectionPreview { text: String, original_text: String, corrections: Vec<CorrectionApplied> } where CorrectionApplied is imported from vocabulary module. Add serde skip_serializing_if for empty corrections vec",
        "Add pending_original_text: Option<String> and pending_corrected_text: Option<String> fields to AppState in state.rs (default None)",
        "In lib.rs transcription complete handler (after let trimmed = text.trim().to_string() and before history::add_entry): check if vocab_enabled in shared state, if so call vocabulary::load_vocabulary() then vocabulary::apply_corrections(&trimmed, &vocab)",
        "If corrections.is_empty(): continue with existing flow (save history with trimmed text, paste immediately)",
        "If corrections NOT empty: save history with corrected text, store original and corrected text in AppState pending fields, emit CorrectionPreview state with text/original_text/corrections, do NOT paste yet, do NOT hide overlay",
        "Add #[tauri::command] fn accept_corrections(app: AppHandle, shared_state: State<SharedState>) -> Result<(), String>: read pending_corrected_text from state, call paste_text with it, clear pending fields, set Idle, hide overlay",
        "Add #[tauri::command] fn undo_corrections(app: AppHandle, shared_state: State<SharedState>) -> Result<(), String>: read pending_original_text from state, call paste_text with it, update the most recent history entry text to original_text, clear pending fields, set Idle, hide overlay",
        "Register accept_corrections and undo_corrections in invoke_handler",
        "Typecheck passes (cargo check in src-tauri)"
      ],
      "priority": 7,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-008",
      "title": "Add correction preview UI in overlay with auto-dismiss and undo",
      "description": "As a user, I want to see which words were corrected in the overlay before paste, with auto-dismiss after 3 seconds and Escape to undo.",
      "acceptanceCriteria": [
        "Add CorrectionPreview type to DictationState union in src/types.ts: { type: 'CorrectionPreview'; text: string; original_text: string; corrections: Array<{ original: string; replacement: string; position: number }> }",
        "In Overlay.tsx: add rendering for CorrectionPreview state showing a compact list of corrections as 'original -> replacement' items (green text for replacement, strikethrough for original), max 5 items shown with '+N more' if exceeded",
        "Add auto-dismiss: when CorrectionPreview state is entered, start a 3-second setTimeout that calls invoke('accept_corrections'). Clear timeout on unmount or state change",
        "Add a thin progress bar or countdown indicator showing remaining time before auto-paste",
        "Add keydown event listener (document.addEventListener) when in CorrectionPreview: Escape key calls invoke('undo_corrections'), Enter key calls invoke('accept_corrections'). Remove listener on cleanup",
        "Show small hint text at bottom: 'Enter to accept · Esc to undo'",
        "Overlay should NOT return null for CorrectionPreview state (it must remain visible during preview)",
        "Typecheck passes (npx tsc --noEmit)"
      ],
      "priority": 8,
      "passes": false,
      "notes": ""
    }
  ]
}
